import numpy as np
from collections import deque
import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s'
    ' - %(message)s')

logging.debug('Start of Program' + f'\n')

class Vec:
    """We create vectors with this class"""
    def __init__(self, labels, function):
        self.D = labels
        self.f = function
        
#Below, sample vectors have been created

u = Vec({'f_1', 'f_2', 'f_3'},{'f_1':1, 'f_2':2, 'f_3':3}) 
v = Vec({'g_1', 'g_2', 'g_3'},{'g_1':4, 'g_2':5, 'g_3':6})
w = Vec({'h_1', 'h_2', 'h_3'},{'h_1':1, 'h_2':2, 'h_3':1})

def construct_3x3_matrix(u, v, w):
    """The vectors u, v, and w will be row vectors in the matrix of B,
which we construct using this function"""
    
    B_u = []
    B_v = []
    B_w = []
    
    lists = deque()
    
    for i in range(len(u.D)):
        B_u.append(u.f[sorted(u.D)[i]])
        B_v.append(v.f[sorted(v.D)[i]])
        B_w.append(w.f[sorted(w.D)[i]])
        
    lists.append(B_u)
    lists.append(B_v)
    lists.append(B_w)
    
    B = np.array(lists)
    return B

# Here is our matrix
B = construct_3x3_matrix(u, v, w)
logging.debug('B is ' + f'\n' + str(B) + f'\n')

# Here is a vector on which the matrix will operate
y = np.array([1, 2, 2])
logging.debug('y is ' + str(y) + f'\n')

def linear_equation(B, y):
    """This function solves for the output vector, c, in our linear equation
By = c, where B is the 3x3 matrix generated by the function
construct_3x3_matrix, y is a 3x1 vector, and c is a 3x1 vector"""
    
    c = []
    
    # We generate the vector c, which is indexed by i
    
    for i in range(len(B)):
        c_i_list = []
        
        # The i^th index of vector c is the sum of terms indexed by j
        # for the given i. We generate those terms with the below for loop.
        
        for j in range(len(y)):
            c_i_j = B[i][j]*y[j]
            c_i_list.append(c_i_j)
        
        # For the i^th index of vector c, we sum those terms indexed by j
        
        c_i = sum(c_i_list)
        c.append(c_i)
    return c
    
c = linear_equation(B, y)
logging.debug('c is ' + str(c) + f'\n')

B_inverse = np.linalg.inv(B)
def check_inverse(B_inverse, c):
    """We use this function to check that our solution for the linear_equation
function above is correct"""
    
    y_i_list = []
    
    # We generate the vector y, which is indexed by i
    
    for i in range(len(B_inverse[0])):
        y_i_j_list = []
        
        # The i^th index of vector y is the sum of terms indexed by j
        # for the given i. We generate those terms with the below for loop.
        
        for j in range(len(c)):
            y_i_j = B_inverse[i][j]*c[j]
            y_i_j_list.append(y_i_j)
            
        # For the i^th index of vector y, we sum those terms indexed by j    
            
        y_i_list.append(int(sum(y_i_j_list)))
    return y_i_list

y_check = check_inverse(B_inverse, c)
logging.debug('y is ' + str(y) + ', as expected.' + f'\n')